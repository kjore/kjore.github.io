<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>查询处理与优化 | kjore's blog</title><meta name="author" content="kjore"><meta name="copyright" content="kjore"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="数据库查询处理 (Query Processing) 1. 核心概念与流程 (Overview) 查询处理的目标是将用户的高级语言（如 SQL）转换成数据库系统能够执行的低级指令，并寻找最高效的执行方式。  三个关键步骤 :  Parsing and translation (解析与翻译): 检查语法，将查询转换成关系代数表达式。 Optimization (优化): 这是最">
<meta property="og:type" content="article">
<meta property="og:title" content="查询处理与优化">
<meta property="og:url" content="https://kjore.github.io/2025/12/10/%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86%E4%B8%8E%E4%BC%98%E5%8C%96/index.html">
<meta property="og:site_name" content="kjore&#39;s blog">
<meta property="og:description" content="数据库查询处理 (Query Processing) 1. 核心概念与流程 (Overview) 查询处理的目标是将用户的高级语言（如 SQL）转换成数据库系统能够执行的低级指令，并寻找最高效的执行方式。  三个关键步骤 :  Parsing and translation (解析与翻译): 检查语法，将查询转换成关系代数表达式。 Optimization (优化): 这是最">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://kjore.github.io/img/head.png">
<meta property="article:published_time" content="2025-12-10T09:22:03.000Z">
<meta property="article:modified_time" content="2025-12-14T08:28:26.018Z">
<meta property="article:author" content="kjore">
<meta property="article:tag" content="笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://kjore.github.io/img/head.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "查询处理与优化",
  "url": "https://kjore.github.io/2025/12/10/%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86%E4%B8%8E%E4%BC%98%E5%8C%96/",
  "image": "https://kjore.github.io/img/head.png",
  "datePublished": "2025-12-10T09:22:03.000Z",
  "dateModified": "2025-12-14T08:28:26.018Z",
  "author": [
    {
      "@type": "Person",
      "name": "kjore",
      "url": "https://kjore.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://kjore.github.io/2025/12/10/%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86%E4%B8%8E%E4%BC%98%E5%8C%96/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '查询处理与优化',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.0.0"></head><body><div id="web_bg" style="background-image: url(/img/bg.png);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/head.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-th-large"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/bg.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/head.png" alt="Logo"><span class="site-name">kjore's blog</span></a><a class="nav-page-title" href="/"><span class="site-name">查询处理与优化</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-th-large"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">查询处理与优化</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-12-10T09:22:03.000Z" title="发表于 2025-12-10 17:22:03">2025-12-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-12-14T08:28:26.018Z" title="更新于 2025-12-14 16:28:26">2025-12-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="数据库查询处理-query-processing">数据库查询处理 (Query
Processing)</h1>
<h3 id="核心概念与流程-overview">1. 核心概念与流程 (Overview)</h3>
<p>查询处理的目标是将用户的高级语言（如
SQL）转换成数据库系统能够执行的低级指令，并寻找最高效的执行方式。</p>
<ul>
<li><strong>三个关键步骤</strong> :
<ol type="1">
<li><strong>Parsing and translation (解析与翻译):</strong>
检查语法，将查询转换成关系代数表达式。</li>
<li><strong>Optimization (优化):</strong>
这是最关键的一步。同一个查询可以有多种执行计划（Plan），优化器负责估算各种计划的代价，找出成本最低的一个。</li>
<li><strong>Evaluation (执行):</strong>
查询执行引擎根据优化后的计划，一步步执行并返回结果。</li>
</ol></li>
</ul>
<h3 id="代价估算指标-measures-of-query-costs">2. 代价估算指标 (Measures
of Query Costs)</h3>
<p>数据库主要关注<strong>磁盘
I/O</strong>，因为它是最慢的环节。我们通常忽略 CPU
开销，主要计算磁盘访问的次数。</p>
<ul>
<li><p><strong>基本符号</strong>:</p>
<ul>
<li><span class="math inline"><em>b</em></span>: 需要传输的数据块
(block) 数量。</li>
<li><span class="math inline"><em>S</em></span>: 寻道 (seek) 次数。</li>
<li><span class="math inline"><em>t</em><sub><em>T</em></sub></span>:
传输一个 block 的时间 (Transfer time)。</li>
<li><span class="math inline"><em>t</em><sub><em>S</em></sub></span>:
一次寻道的时间 (Seek time)。</li>
</ul></li>
<li><p><strong>总代价公式:</strong></p>
<p><span
class="math display"><em>s</em><em>t</em> = <em>b</em> × <em>t</em><sub><em>T</em></sub> + <em>S</em> × <em>t</em><sub><em>S</em></sub></span></p>
<p><em>(意思是：总时间 = 搬运数据的时间 +
找数据位置的时间)</em></p></li>
</ul>
<hr />
<h3 id="选择操作-selection-operation">3. 选择操作 (Selection
Operation)</h3>
<p>如何在表中找到满足条件（例如
<code>salary &lt; 2500</code>）的行？主要有<strong>线性扫描</strong>和<strong>索引扫描</strong>两种方式。</p>
<h4 id="a.-线性扫描-linear-scan-a1">A. 线性扫描 (Linear Scan / A1)</h4>
<ul>
<li><strong>适用场景:</strong> 没有任何索引，或者是堆文件 。</li>
<li><strong>代价:</strong>
<ul>
<li>最坏情况（扫描全表）: <span
class="math inline"><em>t</em><sub><em>S</em></sub> + <em>b</em><sub><em>r</em></sub> × <em>t</em><sub><em>T</em></sub></span>
。</li>
<li>平均情况（<strong>等值查找</strong>且结果唯一）: <span
class="math inline"><em>t</em><sub><em>S</em></sub> + (<em>b</em><sub><em>r</em></sub>/2) × <em>t</em><sub><em>T</em></sub></span>
。</li>
</ul></li>
</ul>
<h4 id="b.二分查找a2binary-search">B.二分查找（A2/binary search)</h4>
<p>数据文件有序，在排序域做等值查询</p>
<h4 id="c.-索引扫描-index-scan">C. 索引扫描 (Index Scan)</h4>
<p>利用索引（如 B+
树）跳着找数据。代价取决于索引类型（聚集/非聚集）和查询类型（等值/范围）。假设
B+ 树高度为 <span
class="math inline"><em>h</em><sub><em>i</em></sub></span>。</p>
<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 21%" />
<col style="width: 42%" />
<col style="width: 30%" />
</colgroup>
<thead>
<tr>
<th style="text-align: left;">算法</th>
<th style="text-align: left;">场景</th>
<th style="text-align: left;">关键点</th>
<th style="text-align: left;">代价估算 (Cost)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>A2</strong></td>
<td style="text-align: left;"><strong>聚集索引 + 等值</strong>
(主键)</td>
<td style="text-align: left;">数据按顺序存，找到索引直接取数据</td>
<td style="text-align: left;"><span
class="math inline">(<em>h</em><sub><em>i</em></sub> + 1) × (<em>t</em><sub><em>T</em></sub> + <em>t</em><sub><em>S</em></sub>)</span></td>
</tr>
<tr>
<td style="text-align: left;"><strong>A3</strong></td>
<td style="text-align: left;"><strong>聚集索引 + 等值</strong>
(非主键)</td>
<td
style="text-align: left;">可能会有多个匹配项，但它们物理上存储在一起</td>
<td style="text-align: left;"><span
class="math inline"><em>h</em><sub><em>i</em></sub>(<em>t</em><sub><em>T</em></sub> + <em>t</em><sub><em>S</em></sub>) + <em>t</em><sub><em>S</em></sub> + <em>t</em><sub><em>T</em></sub> × <em>b</em></span>
(b是匹配块数)</td>
</tr>
<tr>
<td style="text-align: left;"><strong>A4</strong></td>
<td style="text-align: left;"><strong>辅助索引 + 等值</strong></td>
<td style="text-align: left;"><strong>坑点:</strong>
匹配的记录可能散落在磁盘各处，每读一条记录可能都要重新寻道</td>
<td style="text-align: left;"><span
class="math inline">(<em>h</em><sub><em>i</em></sub> + <em>n</em>) × (<em>t</em><sub><em>T</em></sub> + <em>t</em><sub><em>S</em></sub>)</span>
(<span class="math inline"><em>n</em></span>是匹配记录数)</td>
</tr>
<tr>
<td style="text-align: left;"><strong>A5</strong></td>
<td style="text-align: left;"><strong>聚集索引 + 范围</strong> (<span
class="math inline"><em>A</em> &gt; <em>v</em></span>)</td>
<td style="text-align: left;">找到第一个值，然后顺着物理顺序往下读</td>
<td style="text-align: left;">类似 A3，很高效</td>
</tr>
<tr>
<td style="text-align: left;"><strong>A6</strong></td>
<td style="text-align: left;"><strong>辅助索引 + 范围</strong></td>
<td style="text-align: left;">同样因为物理存储不连续，如果<span
class="math inline"><em>n</em></span>
很大，性能极差，甚至不如全表扫描</td>
<td style="text-align: left;"><span
class="math inline">(<em>h</em><sub><em>i</em></sub> + <em>n</em>) × (<em>t</em><sub><em>T</em></sub> + <em>t</em><sub><em>S</em></sub>)</span></td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>🧠 重点提示:</strong> 对于辅助索引（Secondary
Index），如果查询结果很多（<span class="math inline"><em>n</em></span>
很大），使用索引可能比全表扫描还慢，因为随机 I/O (Seek) 太多了！</p>
</blockquote>
<h4 id="d.-复杂选择-complex-selections-不清楚">D. 复杂选择 (Complex
Selections 不清楚)</h4>
<h5 id="第一类处理-and-conjunction">第一类：处理 AND (Conjunction)</h5>
<p>场景：<code>WHERE age = 20 AND dept = 'CS'</code>。我们需要同时满足这两个条件的记录。</p>
<h6 id="a7-单索引过滤-conjunctive-selection-using-one-index"><strong>A7:
单索引过滤 (Conjunctive selection using one index)</strong></h6>
<ul>
<li><p><strong>核心逻辑：</strong> “擒贼先擒王”。</p></li>
<li><p><strong>怎么做：</strong></p>
<ol type="1">
<li><strong>在所有条件中，挑出一个</strong> <strong>代价最小</strong>
（选择性最好、有索引）的条件。</li>
<li><strong>利用这个条件对应的索引，先把这一批候选记录从磁盘读进内存</strong>。</li>
<li>对于剩下的条件，直接在内存里对刚才读进来的记录进行测试过滤。</li>
</ol></li>
</ul>
<h6
id="a8-组合索引-conjunctive-selection-using-composite-index"><strong>A8:
组合索引 (Conjunctive selection using composite index)</strong></h6>
<ul>
<li><strong>核心逻辑：</strong> “一步到位”。</li>
<li><strong>怎么做：</strong>
<ul>
<li><strong>如果数据库里正好有一个包含多个字段的</strong>
<strong>组合索引</strong> （Composite Index，比如建立在(ID,dept_name)
上的索引），那就直接用这个索引查。</li>
<li>这种方式通常最快，因为索引直接覆盖了查询条件，不需要回表或者做额外的内存过滤。</li>
</ul></li>
</ul>
<h6 id="a9-标识符交集-intersection-of-identifiers"><strong>A9:
标识符交集 (Intersection of Identifiers)</strong></h6>
<ul>
<li><strong>核心逻辑：</strong> “多管齐下，先求交集”。</li>
<li><strong>怎么做：</strong>
<ol type="1">
<li>如果每个条件都有索引，那就分别去查这些索引 。</li>
<li><strong>注意！这一步</strong> <strong>不读数据</strong>
<strong>，只拿</strong> <strong>指针</strong> <strong>（Record
Pointers/Identifiers，也就是数据的地址）</strong>。</li>
<li><strong>在内存里把这几组指针求交集 (Intersection)</strong>。</li>
<li>最后，只去取那些“在交集里”的指针对应的实际数据 。</li>
</ol></li>
<li><strong>优点：</strong>
避免了读取那些只满足一个条件但不满足另一个条件的无效数据块，节省了
I/O。</li>
</ul>
<hr />
<h5 id="第二类处理-or-disjunction">第二类：处理 OR (Disjunction)</h5>
<p>场景：<code>WHERE age = 20 OR dept = 'CS'</code>。只要满足其中一个条件就行。</p>
<h6 id="a10-标识符并集-union-of-identifiers"><strong>A10: 标识符并集
(Union of Identifiers)</strong></h6>
<ul>
<li><strong>核心逻辑：</strong> “各自为战，汇总再去重”。</li>
<li><strong>怎么做：</strong>
<ol type="1">
<li><strong>分别利用各个条件的索引，查出满足条件的记录</strong>指针集合
。</li>
<li><strong>在内存里对这些集合求</strong>并集 (Union)。</li>
<li>**根据并集里的指针去磁盘取数据 。</li>
</ol></li>
<li><strong>关键限制：</strong>
<ul>
<li><strong>只有当所有参与 OR
的条件都有索引时，这个算法才适用</strong><sup>13</sup>。</li>
<li><strong>如果其中哪怕有一个条件没有索引（比如age</strong>有索引，但在dept上没索引），数据库通常只能放弃这一招，被迫去做<strong>全表扫描
(Linear
Scan)</strong>。因为没有索引的那个条件可能藏在表的任何角落，不扫全表就找不全。</li>
</ul></li>
</ul>
<h3 id="排序-sorting">4. 排序 (Sorting)</h3>
<p>当内存放不下整个表时，需要进行<strong>外部归并排序 (External
Sort-Merge)</strong>。</p>
<ul>
<li><strong>过程:</strong>
<ol type="1">
<li><strong>分段排序 (Create runs):</strong>
读入一部分数据到内存，排好序，写回磁盘。</li>
<li><strong>归并 (Merge runs):</strong>
将排好序的片段（Runs）逐步合并成一个大的有序文件。</li>
</ol></li>
</ul>
<hr />
<h3 id="连接操作-join-operation-核心考点">5. 连接操作 (Join Operation)
✨ 核心考点</h3>
<p>连接（Join）通常是最耗时的操作。</p>
<h4 id="a.-嵌套循环连接-nested-loop-join">A. 嵌套循环连接 (Nested-Loop
Join)</h4>
<ul>
<li><strong>逻辑:</strong> 两层 <code>for</code>
循环。外层表每一行，都去内层表扫描一遍。</li>
<li><strong>代价:</strong> 极高。最坏情况下（内存只能放一个
block），需要 <span
class="math inline"><em>n</em><sub><em>r</em></sub> × <em>b</em><sub><em>s</em></sub> + <em>b</em><sub><em>r</em></sub></span>
次传输。</li>
<li><strong>优化:</strong> <strong>Block Nested-Loop</strong>
(一次处理一块，减少 I/O)；总是把<strong>小表</strong>作为外层表。</li>
</ul>
<h4 id="b.-索引嵌套循环连接-indexed-nested-loop-join">B.
索引嵌套循环连接 (Indexed Nested-Loop Join)</h4>
<ul>
<li><strong>逻辑:</strong>
外层表循环，内层表利用<strong>索引</strong>查找，不需要全表扫描内层表。</li>
<li><strong>代价:</strong> <span
class="math inline"><em>b</em><sub><em>r</em></sub>(<em>t</em><sub><em>T</em></sub> + <em>t</em><sub><em>S</em></sub>) + <em>n</em><sub><em>r</em></sub> × <em>c</em></span>
(<span class="math inline"><em>c</em></span>
是单次索引查找的代价)。</li>
<li><strong>适用:</strong> 内层表有索引时非常快。</li>
</ul>
<h4 id="c.-归并连接-merge-join">C. 归并连接 (Merge-Join)</h4>
<ul>
<li><strong>前提:</strong>
两个表都必须在连接字段上<strong>排好序</strong>。</li>
<li><strong>逻辑:</strong>
两个指针对齐扫描，类似归并排序的合并步骤。</li>
<li><strong>代价:</strong> 非常低，每个 block 只读一次。<span
class="math inline"><em>b</em><sub><em>r</em></sub> + <em>b</em><sub><em>s</em></sub></span>
次传输。</li>
<li><strong>限制:</strong> 只能用于等值连接 (Equi-joins)。</li>
</ul>
<h4 id="d.-哈希连接-hash-join">D. 哈希连接 (Hash-Join)</h4>
<ul>
<li><strong>逻辑:</strong> 用哈希函数把两个表的数据划分到不同的桶
(Bucket/Partition)。只有同一个桶里的数据才可能匹配。</li>
<li><strong>适用:</strong> 等值连接。</li>
</ul>
<hr />
<h3 id="表达式求值-evaluation-of-expressions">6. 表达式求值 (Evaluation
of Expressions)</h3>
<p>当一个查询包含多个操作（如先选择，再投影，再连接）时，如何传递数据？</p>
<ol type="1">
<li><strong>实体化 (Materialization):</strong>
<ul>
<li>把每一步的中间结果都存到磁盘临时表中。</li>
<li><strong>缺点:</strong> 慢，需要大量的磁盘写操作。</li>
</ul></li>
<li><strong>流水线 (Pipelining):</strong>
<ul>
<li>像工厂流水线一样，上一步产生一个元组（Tuple），立刻传给下一步处理，不写磁盘。</li>
<li><strong>优点:</strong> 高效，无需临时文件，不仅省空间还省时间。</li>
</ul></li>
</ol>
<p>好的，没问题。这份笔记将完全按照“辅导书”的硬核风格编写，剥离废话，通过<strong>逻辑结构</strong>、<strong>核心公式</strong>和<strong>算法步骤</strong>来拆解《数据库系统原理》第16章“查询优化”的核心考点。</p>
<hr />
<h1 id="数据库系统原理核心笔记查询优化-query-optimization">📚
数据库系统原理核心笔记：查询优化 (Query Optimization)</h1>
<h2 id="查询优化概述-overview">查询优化概述 (Overview)</h2>
<p>查询优化的核心目标是为给定的 SQL
查询找到执行成本（Cost）最低的执行计划。</p>
<h3 id="优化流程-procedure">1.1 优化流程 (Procedure)</h3>
<p>查询优化通常分为三个核心步骤：</p>
<ol type="1">
<li><strong>查询重写 (Query Rewriting):</strong>
利用关系代数的<strong>等价规则 (Equivalence
Rules)</strong>，将初始的关系代数表达式转换为逻辑上等价但效率更高的形式（生成等价查询树）。</li>
<li><strong>计划生成 (Plan Generation):</strong>
为逻辑查询树中的每个操作（如连接、选择）标注具体的<strong>实现算法</strong>（如
Hash Join, Index Scan），并决定是采用流水线 (Pipelining) 还是物化
(Materialization) 策略，生成候选执行计划。</li>
<li><strong>代价评估与选择 (Cost Estimation &amp; Selection):</strong>
基于统计信息估算每个计划的执行代价，选择最优或次优计划。</li>
</ol>
<h3 id="为什么需要优化">1.2 为什么需要优化？</h3>
<p>同一个 SQL
语句可以对应多种等价的关系代数表达式，其执行效率差异巨大。</p>
<ul>
<li><strong>案例：</strong> <span
class="math inline"><em>σ</em><sub><em>r</em>.<em>A</em> = <em>s</em>.<em>A</em></sub>(<em>r</em> × <em>s</em>)</span>
（先做笛卡尔积再筛选）的效率远低于 <span
class="math inline"><em>r</em> ⋈ <em>s</em></span> （直接连接）。</li>
<li><strong>差异量级：</strong> 优化前后的代价差异可能达到秒级 vs 天级
。</li>
</ul>
<hr />
<h2 id="查询重写与等价规则-equivalence-rules">查询重写与等价规则
(Equivalence Rules)</h2>
<p>这是基于<strong>启发式规则 (Heuristics)</strong>
进行优化的理论基础。如果两个关系代数表达式在任何合法的数据库实例上产生相同的结果集，则称它们是等价的。</p>
<h3 id="核心等价规则-key-rules">2.1 核心等价规则 (Key Rules)</h3>
<ol type="1">
<li><p><strong>选择操作 (Selection):</strong></p>
<ul>
<li><strong>串接律 (Cascade):</strong> <span
class="math inline"><em>σ</em><sub><em>θ</em><sub>1</sub> ∧ <em>θ</em><sub>2</sub></sub>(<em>E</em>) = <em>σ</em><sub><em>θ</em><sub>1</sub></sub>(<em>σ</em><sub><em>θ</em><sub>2</sub></sub>(<em>E</em>))</span>。这意味着可以将复杂的
AND 条件拆分为多个简单的选择。</li>
<li><strong>交换律 (Commutativity):</strong> <span
class="math inline"><em>σ</em><sub><em>θ</em><sub>1</sub></sub>(<em>σ</em><sub><em>θ</em><sub>2</sub></sub>(<em>E</em>)) = <em>σ</em><sub><em>θ</em><sub>2</sub></sub>(<em>σ</em><sub><em>θ</em><sub>1</sub></sub>(<em>E</em>))</span>。这允许调整过滤条件的顺序，先执行过滤性强的条件。</li>
</ul></li>
<li><p><strong>投影操作 (Projection):</strong></p>
<ul>
<li><strong>串接律:</strong> <span
class="math inline"><em>Π</em><sub><em>L</em><sub>1</sub></sub>(<em>Π</em><sub><em>L</em><sub>2</sub></sub>(...(<em>Π</em><sub><em>L</em><sub><em>n</em></sub></sub>(<em>E</em>))...)) = <em>Π</em><sub><em>L</em><sub>1</sub></sub>(<em>E</em>)</span>，其中
<span
class="math inline"><em>L</em><sub>1</sub> ⊆ <em>L</em><sub>2</sub></span>。只保留最后需要的列。</li>
</ul></li>
<li><p><strong>连接操作 (Join) —— 重点:</strong></p>
<ul>
<li><strong>交换律:</strong> <span
class="math inline"><em>E</em><sub>1</sub> ⋈ <em>E</em><sub>2</sub> = <em>E</em><sub>2</sub> ⋈ <em>E</em><sub>1</sub></span>。</li>
<li><strong>结合律:</strong> <span
class="math inline">(<em>E</em><sub>1</sub> ⋈ <em>E</em><sub>2</sub>) ⋈ <em>E</em><sub>3</sub> = <em>E</em><sub>1</sub> ⋈ (<em>E</em><sub>2</sub> ⋈ <em>E</em><sub>3</sub>)</span>。这构成了<strong>连接顺序选择
(Join Ordering)</strong> 的基础。</li>
<li><strong>小技巧:</strong>
通常将较小的关系作为连接操作的左操作数（Outer
Relation）以降低代价。</li>
</ul></li>
<li><p><strong>选择下移 (Pushing Selection) ——
核心优化手段:</strong></p>
<ul>
<li><strong>Rule 7a:</strong> 如果选择条件 <span
class="math inline"><em>θ</em><sub>0</sub></span> 只涉及 <span
class="math inline"><em>E</em><sub>1</sub></span> 的属性，则 <span
class="math inline"><em>σ</em><sub><em>θ</em><sub>0</sub></sub>(<em>E</em><sub>1</sub> ⋈ <em>E</em><sub>2</sub>) = (<em>σ</em><sub><em>θ</em><sub>0</sub></sub>(<em>E</em><sub>1</sub>)) ⋈ <em>E</em><sub>2</sub></span>。</li>
<li><strong>Rule 7b:</strong>
如果条件可以拆分，应分别下推到对应的子表达式中：<span
class="math inline"><em>σ</em><sub><em>θ</em><sub>1</sub> ∧ <em>θ</em><sub>2</sub></sub>(<em>E</em><sub>1</sub> ⋈ <em>E</em><sub>2</sub>) = (<em>σ</em><sub><em>θ</em><sub>1</sub></sub>(<em>E</em><sub>1</sub>)) ⋈ (<em>σ</em><sub><em>θ</em><sub>2</sub></sub>(<em>E</em><sub>2</sub>))</span>。</li>
<li><strong>目的:</strong> 尽早过滤数据，减小参与连接的元组数量。</li>
</ul></li>
<li><p><strong>投影下移 (Pushing Projection):</strong></p>
<ul>
<li><strong>Rule 8:</strong>
将投影操作尽可能下移到连接之前，仅保留后续操作需要的属性（连接属性 +
最终结果属性），以减少中间结果的宽度（元组大小）。</li>
</ul></li>
</ol>
<h3 id="启发式优化算法的-6-个步骤-heuristic-optimization-steps">2.2
启发式优化算法的 6 个步骤 (Heuristic Optimization Steps)</h3>
<p>这是一套标准的处理流程，用于将初始查询树转换为优化后的查询树：</p>
<ol type="1">
<li><strong>分解选择:</strong> 利用 Rule 1 将连接条件（Conjunctive
Selection）分解为单个选择操作序列。</li>
<li><strong>下移选择:</strong> 利用 Rule 2, 7a, 7b,
11，将选择操作尽可能移动到查询树的叶端。</li>
<li><strong>重排叶节点:</strong> 利用 Rule 6 (结合律/交换律)
调整叶节点顺序，让<strong>限制性最强 (Most Restrictive)</strong>
的选择操作最先执行。</li>
<li><strong>替换笛卡尔积:</strong> 利用 Rule 4a，将相邻的“笛卡尔积 +
选择”合并为“连接”操作 (<span class="math inline">⋈</span>)。</li>
<li><strong>下移投影:</strong> 利用 Rule 3, 8a, 8b,
12，将投影操作下移，甚至在每一层都增加投影，尽早丢弃无用属性。</li>
<li><strong>识别流水线:</strong>
将查询树分解，识别可以流水线执行的子树。</li>
</ol>
<hr />
<h2
id="统计信息与基数代价估计-statistics-cost-estimation">统计信息与基数/代价估计
(Statistics &amp; Cost Estimation)</h2>
<p>代价估算 (Cost Estimation) 是基于数据库目录 (Catalog)
中的统计信息来进行的。</p>
<h3 id="关键统计指标-catalog-information">3.1 关键统计指标 (Catalog
Information)</h3>
<ul>
<li><span class="math inline"><em>n</em><sub><em>r</em></sub></span>:
关系 <span class="math inline"><em>r</em></span> 的元组总数。</li>
<li><span class="math inline"><em>b</em><sub><em>r</em></sub></span>:
关系 <span class="math inline"><em>r</em></span> 占用的磁盘块数。</li>
<li><span class="math inline"><em>l</em><sub><em>r</em></sub></span>:
<span class="math inline"><em>r</em></span>
中每个元组的平均字节大小。</li>
<li><span class="math inline"><em>f</em><sub><em>r</em></sub></span>:
块因子，即一个磁盘块能容纳的元组数 (<span
class="math inline"><em>b</em><sub><em>r</em></sub> = ⌈<em>n</em><sub><em>r</em></sub>/<em>f</em><sub><em>r</em></sub>⌉</span>)。</li>
<li><span class="math inline"><em>V</em>(<em>A</em>, <em>r</em>)</span>:
属性 <span class="math inline"><em>A</em></span> 在关系 <span
class="math inline"><em>r</em></span> 中的<strong>不同值个数 (Distinct
Values)</strong>。</li>
</ul>
<h3 id="结果大小估算公式-size-estimation-formulas">3.2 结果大小估算公式
(Size Estimation Formulas)</h3>
<p>准确估算中间结果的大小 (Cardinality) 是计算代价的前提。</p>
<p><strong>1. 选择操作 (<span
class="math inline"><em>σ</em></span>):</strong></p>
<ul>
<li><strong>等值查询 (<span
class="math inline"><em>A</em> = <em>a</em></span>):</strong>
假设数据均匀分布，结果行数为 <span
class="math inline"><em>n</em><sub><em>r</em></sub>/<em>V</em>(<em>A</em>, <em>r</em>)</span>。</li>
<li><strong>主键等值 (<span
class="math inline"><em>I</em><em>D</em> = <em>k</em><em>e</em><em>y</em></span>):</strong>
结果行数为 1。</li>
<li><strong>范围查询 (<span
class="math inline"><em>A</em> ≤ <em>v</em></span>):</strong>
利用最大最小值进行线性插值：<span class="math inline">$n_r \cdot \frac{v
- min(A,r)}{max(A,r) - min(A,r)}$</span>。</li>
<li><strong>复杂条件 (Conjunction):</strong> 假设条件独立，<span
class="math inline">$\sigma_{\theta_1 \land \theta_2}(r) = n_r \cdot
\frac{S_1}{n_r} \cdot \frac{S_2}{n_r}$</span>。</li>
</ul>
<p><strong>2. 连接操作 (<span
class="math inline"><em>r</em> ⋈ <em>s</em></span>):</strong></p>
<ul>
<li><strong>外键连接:</strong> 如果 <span
class="math inline"><em>r</em></span> 与 <span
class="math inline"><em>s</em></span> 的连接基于 <span
class="math inline"><em>s</em></span> 的外键（指向 <span
class="math inline"><em>r</em></span> 的主键），则结果大小严格等于 <span
class="math inline"><em>s</em></span> 的大小 (<span
class="math inline"><em>n</em><sub><em>s</em></sub></span>)。</li>
<li><strong>一般连接:</strong>
如果两个表的连接属性都不是主键，估算公式取较小值： <span
class="math display">$$
ze = \min \left( \frac{n_r \cdot n_s}{V(A, r)}, \frac{n_r \cdot
n_s}{V(A, s)} \right)
$$</span></li>
</ul>
<hr />
<h2 id="优化方法与策略-optimization-approaches">优化方法与策略
(Optimization Approaches)</h2>
<h3 id="基于代价的优化-cost-based-optimization---cbo">4.1 基于代价的优化
(Cost-Based Optimization - CBO)</h3>
<ul>
<li><strong>原理:</strong>
枚举所有可能的执行计划，计算每个计划的代价，选择最小者。</li>
<li><strong>连接顺序 (Join Ordering):</strong>
连接操作的顺序对代价影响巨大。对于 <span
class="math inline"><em>N</em></span> 个表的连接，存在 <span
class="math inline">(2(<em>N</em> − 1))!/(<em>N</em> − 1)!</span>
种顺序，搜索空间极大。</li>
<li><strong>解决方法:</strong> 采用<strong>动态规划 (Dynamic
Programming)</strong> 算法，类似于矩阵连乘问题。对于子集 <span
class="math inline">{<em>r</em><sub>1</sub>, <em>r</em><sub>2</sub>, ..., <em>r</em><sub><em>n</em></sub>}</span>
的最优连接顺序只需计算一次并存储。</li>
</ul>
<h3 id="启发式优化-heuristic-optimization">4.2 启发式优化 (Heuristic
Optimization)</h3>
<ul>
<li><strong>原理:</strong>
基于经验规则（如“尽早过滤”）直接修剪查询树，而不计算所有可能的代价。</li>
<li><strong>适用性:</strong> 现代优化器通常结合使用 CBO
和启发式方法。先用启发式规则重写查询（如视图展开、条件化简），再用 CBO
选择具体的物理计划。</li>
</ul>
<h3 id="新兴技术-ai4db">4.3 新兴技术 (AI4DB)</h3>
<ul>
<li>利用机器学习（如强化学习 RL）来解决传统基数估计（Cardinality
Estimation）不准的问题。</li>
<li>利用 AI 自动枚举和选择连接顺序，甚至实现端到端的查询优化。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://kjore.github.io">kjore</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://kjore.github.io/2025/12/10/%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86%E4%B8%8E%E4%BC%98%E5%8C%96/">https://kjore.github.io/2025/12/10/%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86%E4%B8%8E%E4%BC%98%E5%8C%96/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://kjore.github.io" target="_blank">kjore's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AC%94%E8%AE%B0/">笔记</a></div><div class="post-share"><div class="social-share" data-image="/img/head.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/12/10/%E7%B4%A2%E5%BC%95/" title="物理存储结构与索引"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">物理存储结构与索引</div></div><div class="info-2"><div class="info-item-1">存储与文件结构 文件组织 定长记录与变长记录  定长记录（fixed-length record）：每条记录的长度相同，便于计算和存取 变长记录（variable-length record）：每条记录的长度不同，节省空间，但存取较复杂  文件中记录的组织 堆文件组织（heap file organization） 记录无特定顺序存储，适用于插入频繁但查询较少的场景 ### 顺序文件组织（sequential file organization） 记录按某一属性排序存储，适用于范围查询和顺序访问 ### 散列文件组织（hashed file organization） 记录通过哈希函数映射到存储位置，适用于等值查询 ### 多表聚簇文件组织 (clustered file organization) 将相关表的数据存储在一起，提高联接查询效率 数据字典 (Data Dictionary / System Catalog) 它是“数据库的数据库”。 存什么？ 元数据 (Metadata)。即关于数据的数据。 - 表名、列名、列的类型。 -...</div></div></div></a><a class="pagination-related" href="/2025/12/09/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/" title=""><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2"></div></div><div class="info-2"><div class="info-item-1">操作系统文件管理学习笔记 文件 文件是命名的、具有逻辑结构的、存储在辅助存储器上的数据集合。它是用户与操作系统之间交互的最基本单位。 • 数据项 (Data Item): 数据的最小命名单位，如字段、记录。分为基本数据项和复合数据项。 • 记录 (Record): 一组相关的数据项的集合。 • 文件 (File): 一组相关记录的集合，分为有结构文件和无结构文件两种，在有结构的文件中，文件由若干个相似记录组成，而无结构文件是一个连续的字节流（如在 UNIX 或 Linux 中）。 文件属性  文件名 (File Name): 同一目录下不能有相同文件名的文件。 标识符 (Identifier): 用于唯一标识文件的标识符。 文件类型 (File Type): 文件的类别，如文本文件、二进制文件等 文件位置 (File Location): 文件存放路径（让用户使用）。在外存的地址（用户不可见）。 文件大小 (File Size): 文件占用的存储空间大小。 创建时间 (Creation Time): 文件被创建的时间和最后一次修改时间。 创建者...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/11/11/SQL/" title="SQL"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-11-11</div><div class="info-item-2">SQL</div></div><div class="info-2"><div class="info-item-1">SQL数据定义  char(n) :n个长度的固定字符串 varchar(n) :最大n个长度的可变长字符串 int :整数 smallint :小整数 numeric(p,d) :这个数有p位数字，小数点后d位数字。如numeric(3,1)可以存储33.3 ,44.4 float(n) :精度至少为n的单精度浮点数 double :双精度浮点数 date :日期，格式YYYY-MM-DD time :时间，格式HH:MM:SS timestamp :时间戳，格式YYYY-MM-DD HH:MM:SS  DDL DDL是数据库定义语言，用于创建修改删除数据库的结构 创建数据库 1234567891011create table table_name(    id int,    name char(10) not null,    age int,    gender char(1) default &#x27;M&#x27;,    address varchar(50),    primary key(id),    unique(name...</div></div></div></a><a class="pagination-related" href="/2025/10/28/%E6%AD%BB%E9%94%81/" title="死锁"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-28</div><div class="info-item-2">死锁</div></div><div class="info-2"><div class="info-item-1">死锁 deadlock 概念 定义 在计算机科学中，死锁（Deadlock）是指两个或多个进程在执行过程中，由于竞争资源而造成的一种互相等待的现象，从而导致这些进程无法继续执行。 死锁与饥饿的区别  发生饥饿的进程可以只有一个，发生死锁的进程有两个或两个以上。 发生饥饿的进程可能处于就绪态，比如SJF调度算法中，优先级低的进程可能一直得不到执行机会而处于就绪态，也可能处于阻塞态，如长期得不到I/O设备。而发生死锁的进程一般都处于阻塞态，等待其他进程释放资源。  死锁的必要条件  互斥条件（mutual exclusion）：至少有一个资源必须处于非共享模式，即某个资源一次只能被一个进程占用。 占有且等待条件（hold and wait）：持有至少一种资源的进程正在等待获取其他进程持有的其他资源 非抢占式（no preemption）：进程已获得的资源在未使用完之前，不能被强制剥夺，只能在进程完成其任务后由进程自己释放。 循环等待条件（circular wait）：存在一种进程资源的循环等待关系，即P1等待P2占有的资源，P2等待P3占有的资源，...</div></div></div></a><a class="pagination-related" href="/2025/10/22/%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B/" title="关系模型"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-22</div><div class="info-item-2">关系模型</div></div><div class="info-2"><div class="info-item-1">关系模型 Relational Model 关系模型的结构 Relational Model Structure 关系：笛卡尔乘积的有意义的有限子集 属性：关系的列，属性的顺序不重要，属性必须是原子的 元组：关系的行，或者一条记录，元组的顺序不重要 域(domain)：属性的取值范围 关系模式：关系的结构描述，一个属性列表及属性所对应的域 关系实例：关系在某一时刻的具体数据，快照 关系模型的约束 Constraints of Relational Model 超键(superkey)：能唯一标识元组的属性集合。如学号加姓名 候选键(candidate key)：最小超键，不能再去掉任何属性的超键。如学号。候选键不唯一，比如学号可以是候选键，身份证号也可以是候选键  唯一性 最小性  主键(primary key)：从候选键中选出的用于唯一标识元组的属性集合。如学号 外键(foreign key)：一个关系中的属性，其值引用另一个关系的主键或候选键 完整性约束： 实体完整性：主键属性不能为空 参照完整性：外键值要么为空，要么必须在引用的...</div></div></div></a><a class="pagination-related" href="/2025/12/10/%E7%B4%A2%E5%BC%95/" title="物理存储结构与索引"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-10</div><div class="info-item-2">物理存储结构与索引</div></div><div class="info-2"><div class="info-item-1">存储与文件结构 文件组织 定长记录与变长记录  定长记录（fixed-length record）：每条记录的长度相同，便于计算和存取 变长记录（variable-length record）：每条记录的长度不同，节省空间，但存取较复杂  文件中记录的组织 堆文件组织（heap file organization） 记录无特定顺序存储，适用于插入频繁但查询较少的场景 ### 顺序文件组织（sequential file organization） 记录按某一属性排序存储，适用于范围查询和顺序访问 ### 散列文件组织（hashed file organization） 记录通过哈希函数映射到存储位置，适用于等值查询 ### 多表聚簇文件组织 (clustered file organization) 将相关表的数据存储在一起，提高联接查询效率 数据字典 (Data Dictionary / System Catalog) 它是“数据库的数据库”。 存什么？ 元数据 (Metadata)。即关于数据的数据。 - 表名、列名、列的类型。 -...</div></div></div></a><a class="pagination-related" href="/2025/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/" title="计算机系统概述"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-29</div><div class="info-item-2">计算机系统概述</div></div><div class="info-2"><div class="info-item-1">计算机系统概述 操作系统基本概念 操作系统作为用户和计算机硬件系统之间的接口 命令接口  联机命令接口又称交互式命令接口 脱机命令接口又称批处理命令接口  程序接口（系统调用）system call 系统调用是操作系统提供给编程人员使用的接口，是操作系统为用户程序使用内核服务使用的接口 操作系统分类 批处理操作系统 batch OS 提高了计算机的利用率，但人机交互差 分时操作系统 time-sharing OS 较好解决人机交互（interactive）问题，解决交互式作业，多用户操作系统，快速响应用户 实时操作系统 real-time OS 在规定时间内完成对外部事件的响应和处理 操作系统运行模式 用户态 user mode 1和内核态 kernel mode 0 中断和异常 中断服务程序属于操作系统内核。程序计数器PC和程序状态字PSW，程序断点由硬件保存，中断服务程序保存中断屏蔽字，通用寄存器的值，中断向量表由操作系统初始化 操作系统引导 计算机加电后，CPU自动执行预定地址的指令，这些指令通常存放在只读存储器ROM中，这些指...</div></div></div></a><a class="pagination-related" href="/2025/10/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/" title="数据库设计"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-21</div><div class="info-item-2">数据库设计</div></div><div class="info-2"><div class="info-item-1">数据库设计 概念模式设计 E-R模型 实体集 entity sets 具有相同属性attributes的实体构成一个实体集。实体指一个具体的个体，如一个特殊的人，一个公司，一件事。 下图为实体集的E-R图  属性 attributes  简单属性（Simple）：不可再分的属性 复合属性（composite）：可在分的属性 用缩进表示  根据用户需求来确定属性是简单的还是复杂的。比如姓名这个属性，根据用户需求可看成一整个名字的简单属性，也可以看成姓和名的复合属性。  单值属性（Single-valued）：在这个属性上的取值只有一个。比如性别，要么是男，要么是女，不可能同时是男和女。 多值属性（multivalued）：比如联系方式，可以填多个电话或邮箱 用{}表示 导出属性（Derived）：可以由其他属性推导出来。比如年龄可以根据生日算出。导出属性可以在数据库中存也可以不存，存的话得到属性比较快，但是，不仅占空间，而且需要维护它和其他属性的一致性。所以对于一些简单的逻辑关系，就不保存了。 用（）表示   联系集 relationship...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/head.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">kjore</div><div class="author-info-description">什么都不懂</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/kjore"><i class="fab fa-github"></i><span>关注我</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:zhangjingye@bupt.edu.cn" target="_blank" title="邮箱"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86-query-processing"><span class="toc-number">1.</span> <span class="toc-text">数据库查询处理 (Query
Processing)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%B5%81%E7%A8%8B-overview"><span class="toc-number">1.0.1.</span> <span class="toc-text">1. 核心概念与流程 (Overview)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E4%BB%B7%E4%BC%B0%E7%AE%97%E6%8C%87%E6%A0%87-measures-of-query-costs"><span class="toc-number">1.0.2.</span> <span class="toc-text">2. 代价估算指标 (Measures
of Query Costs)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%93%8D%E4%BD%9C-selection-operation"><span class="toc-number">1.0.3.</span> <span class="toc-text">3. 选择操作 (Selection
Operation)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a.-%E7%BA%BF%E6%80%A7%E6%89%AB%E6%8F%8F-linear-scan-a1"><span class="toc-number">1.0.3.1.</span> <span class="toc-text">A. 线性扫描 (Linear Scan &#x2F; A1)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BEa2binary-search"><span class="toc-number">1.0.3.2.</span> <span class="toc-text">B.二分查找（A2&#x2F;binary search)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c.-%E7%B4%A2%E5%BC%95%E6%89%AB%E6%8F%8F-index-scan"><span class="toc-number">1.0.3.3.</span> <span class="toc-text">C. 索引扫描 (Index Scan)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#d.-%E5%A4%8D%E6%9D%82%E9%80%89%E6%8B%A9-complex-selections-%E4%B8%8D%E6%B8%85%E6%A5%9A"><span class="toc-number">1.0.3.4.</span> <span class="toc-text">D. 复杂选择 (Complex
Selections 不清楚)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%B1%BB%E5%A4%84%E7%90%86-and-conjunction"><span class="toc-number">1.0.3.4.1.</span> <span class="toc-text">第一类：处理 AND (Conjunction)</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#a7-%E5%8D%95%E7%B4%A2%E5%BC%95%E8%BF%87%E6%BB%A4-conjunctive-selection-using-one-index"><span class="toc-number">1.0.3.4.1.1.</span> <span class="toc-text">A7:
单索引过滤 (Conjunctive selection using one index)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#a8-%E7%BB%84%E5%90%88%E7%B4%A2%E5%BC%95-conjunctive-selection-using-composite-index"><span class="toc-number">1.0.3.4.1.2.</span> <span class="toc-text">A8:
组合索引 (Conjunctive selection using composite index)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#a9-%E6%A0%87%E8%AF%86%E7%AC%A6%E4%BA%A4%E9%9B%86-intersection-of-identifiers"><span class="toc-number">1.0.3.4.1.3.</span> <span class="toc-text">A9:
标识符交集 (Intersection of Identifiers)</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%B1%BB%E5%A4%84%E7%90%86-or-disjunction"><span class="toc-number">1.0.3.4.2.</span> <span class="toc-text">第二类：处理 OR (Disjunction)</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#a10-%E6%A0%87%E8%AF%86%E7%AC%A6%E5%B9%B6%E9%9B%86-union-of-identifiers"><span class="toc-number">1.0.3.4.2.1.</span> <span class="toc-text">A10: 标识符并集
(Union of Identifiers)</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F-sorting"><span class="toc-number">1.0.4.</span> <span class="toc-text">4. 排序 (Sorting)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E6%93%8D%E4%BD%9C-join-operation-%E6%A0%B8%E5%BF%83%E8%80%83%E7%82%B9"><span class="toc-number">1.0.5.</span> <span class="toc-text">5. 连接操作 (Join Operation)
✨ 核心考点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a.-%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF%E8%BF%9E%E6%8E%A5-nested-loop-join"><span class="toc-number">1.0.5.1.</span> <span class="toc-text">A. 嵌套循环连接 (Nested-Loop
Join)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b.-%E7%B4%A2%E5%BC%95%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF%E8%BF%9E%E6%8E%A5-indexed-nested-loop-join"><span class="toc-number">1.0.5.2.</span> <span class="toc-text">B.
索引嵌套循环连接 (Indexed Nested-Loop Join)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c.-%E5%BD%92%E5%B9%B6%E8%BF%9E%E6%8E%A5-merge-join"><span class="toc-number">1.0.5.3.</span> <span class="toc-text">C. 归并连接 (Merge-Join)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#d.-%E5%93%88%E5%B8%8C%E8%BF%9E%E6%8E%A5-hash-join"><span class="toc-number">1.0.5.4.</span> <span class="toc-text">D. 哈希连接 (Hash-Join)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC-evaluation-of-expressions"><span class="toc-number">1.0.6.</span> <span class="toc-text">6. 表达式求值 (Evaluation
of Expressions)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E6%A0%B8%E5%BF%83%E7%AC%94%E8%AE%B0%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96-query-optimization"><span class="toc-number">2.</span> <span class="toc-text">📚
数据库系统原理核心笔记：查询优化 (Query Optimization)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E6%A6%82%E8%BF%B0-overview"><span class="toc-number">2.1.</span> <span class="toc-text">查询优化概述 (Overview)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E6%B5%81%E7%A8%8B-procedure"><span class="toc-number">2.1.1.</span> <span class="toc-text">1.1 优化流程 (Procedure)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%BC%98%E5%8C%96"><span class="toc-number">2.1.2.</span> <span class="toc-text">1.2 为什么需要优化？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E9%87%8D%E5%86%99%E4%B8%8E%E7%AD%89%E4%BB%B7%E8%A7%84%E5%88%99-equivalence-rules"><span class="toc-number">2.2.</span> <span class="toc-text">查询重写与等价规则
(Equivalence Rules)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%AD%89%E4%BB%B7%E8%A7%84%E5%88%99-key-rules"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.1 核心等价规则 (Key Rules)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8F%91%E5%BC%8F%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95%E7%9A%84-6-%E4%B8%AA%E6%AD%A5%E9%AA%A4-heuristic-optimization-steps"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.2
启发式优化算法的 6 个步骤 (Heuristic Optimization Steps)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E4%BF%A1%E6%81%AF%E4%B8%8E%E5%9F%BA%E6%95%B0%E4%BB%A3%E4%BB%B7%E4%BC%B0%E8%AE%A1-statistics-cost-estimation"><span class="toc-number">2.3.</span> <span class="toc-text">统计信息与基数&#x2F;代价估计
(Statistics &amp; Cost Estimation)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E7%BB%9F%E8%AE%A1%E6%8C%87%E6%A0%87-catalog-information"><span class="toc-number">2.3.1.</span> <span class="toc-text">3.1 关键统计指标 (Catalog
Information)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%9C%E5%A4%A7%E5%B0%8F%E4%BC%B0%E7%AE%97%E5%85%AC%E5%BC%8F-size-estimation-formulas"><span class="toc-number">2.3.2.</span> <span class="toc-text">3.2 结果大小估算公式
(Size Estimation Formulas)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%E4%B8%8E%E7%AD%96%E7%95%A5-optimization-approaches"><span class="toc-number">2.4.</span> <span class="toc-text">优化方法与策略
(Optimization Approaches)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E4%BB%A3%E4%BB%B7%E7%9A%84%E4%BC%98%E5%8C%96-cost-based-optimization---cbo"><span class="toc-number">2.4.1.</span> <span class="toc-text">4.1 基于代价的优化
(Cost-Based Optimization - CBO)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8F%91%E5%BC%8F%E4%BC%98%E5%8C%96-heuristic-optimization"><span class="toc-number">2.4.2.</span> <span class="toc-text">4.2 启发式优化 (Heuristic
Optimization)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E5%85%B4%E6%8A%80%E6%9C%AF-ai4db"><span class="toc-number">2.4.3.</span> <span class="toc-text">4.3 新兴技术 (AI4DB)</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/12/10/%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86%E4%B8%8E%E4%BC%98%E5%8C%96/" title="查询处理与优化">查询处理与优化</a><time datetime="2025-12-10T09:22:03.000Z" title="发表于 2025-12-10 17:22:03">2025-12-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/12/10/%E7%B4%A2%E5%BC%95/" title="物理存储结构与索引">物理存储结构与索引</a><time datetime="2025-12-10T09:22:03.000Z" title="发表于 2025-12-10 17:22:03">2025-12-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/12/09/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/" title="无标题">无标题</a><time datetime="2025-12-09T08:59:55.629Z" title="发表于 2025-12-09 16:59:55">2025-12-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/11/16/conda%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" title="conda 常用命令">conda 常用命令</a><time datetime="2025-11-16T07:28:02.000Z" title="发表于 2025-11-16 15:28:02">2025-11-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/11/14/DARLING/" title="《共同加强语言模型生成的多样性和质量》论文深度研读">《共同加强语言模型生成的多样性和质量》论文深度研读</a><time datetime="2025-11-14T07:28:02.000Z" title="发表于 2025-11-14 15:28:02">2025-11-14</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By kjore</span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.1"></script><script src="/js/main.js?v=5.5.1"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        loader: {
          load: [
            // Four font extension packages (optional)
            //- '[tex]/bbm',
            //- '[tex]/bboldx',
            //- '[tex]/dsfont',
            '[tex]/mhchem'
          ],
          paths: {
            'mathjax-newcm': '[mathjax]/../@mathjax/mathjax-newcm-font',

            //- // Four font extension packages (optional)
            //- 'mathjax-bbm-extension': '[mathjax]/../@mathjax/mathjax-bbm-font-extension',
            //- 'mathjax-bboldx-extension': '[mathjax]/../@mathjax/mathjax-bboldx-font-extension',
            //- 'mathjax-dsfont-extension': '[mathjax]/../@mathjax/mathjax-dsfont-font-extension',
            'mathjax-mhchem-extension': '[mathjax]/../@mathjax/mathjax-mhchem-font-extension'
          }
        },
        output: {
          font: 'mathjax-newcm',
        },
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
          packages: {
            '[+]': [
              'mhchem'
            ]
          }
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          menuOptions: {
            settings: {
              enrich: false  // Turn off Braille and voice narration text automatic generation
            }
          },
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }

      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax@4.0.0/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>